# 웨이팅 신청 동시성 제어 및 대기열 시스템

## 1. 개요

인기 상점에 대한 웨이팅 신청 시 발생하는 **동시성 문제(Race Condition)**와 **DB 부하**를 해결하기 위해 단계별 고도화를 진행한 기술적인 결정과 구현 내용에 대해 설명합니다.
- **V2**: Redisson을 이용한 분산락 적용 (데이터 정합성 보장)
- **V3**: Kafka를 이용한 대기열 시스템 적용 (순서 보장 및 트래픽 제어)

## 2. V2: 분산락(Distributed Lock) 적용

### 왜 Redisson을 사용했는가?

- **데이터 정합성 보장**:
    - 동시에 여러 사용자가 웨이팅을 신청할 때, 웨이팅 번호 중복이나 순서 꼬임 방지가 필수적입니다.
    - Java의 `synchronized`는 다중 서버 환경에서 동작하지 않으며, DB 락(Pessimistic Lock)은 성능 저하를 유발할 수 있습니다.
    - Redis 기반의 분산락은 다중 서버 환경에서도 일관된 락을 제공하며, In-memory 기반이라 락 획득/해제 속도가 빠릅니다.

- **스핀 락(Spin Lock) 부하 해결**:
    - Redis의 기본 명령어(`SETNX`)를 이용한 스핀 락 방식은 락 획득을 위해 Redis에 지속적인 요청을 보내 부하를 줍니다.
    - **Redisson**은 Pub/Sub 방식을 사용하여 락 해제 시에만 알림을 받아 락 획득을 시도하므로, Redis 부하를 획기적으로 줄일 수 있습니다.

- **기존 인프라 활용**:
    - 프로젝트에서 이미 Redis를 사용 중이므로 추가적인 인프라 구축 비용이 들지 않습니다.

### 구현 상세 및 근거

- **Key 설계**:
    - `store_waiting:{storeId}` 형태의 Key를 사용합니다.
    - 상점별(`storeId`)로 락을 구분하여, 서로 다른 상점에 대한 웨이팅 신청은 병렬로 처리될 수 있도록 하여 성능을 확보했습니다.

- **`executeWithLock` 메서드 추상화**:
    - 락 획득, 비즈니스 로직 실행, 락 해제(finally 블록)로 이어지는 상용구 코드를 `executeWithLock` 메서드로 분리했습니다.
    - 이를 통해 비즈니스 로직의 가독성을 높이고, 락 해제 누락과 같은 실수를 방지했습니다.

- **WaitTime & LeaseTime 설정**:
    - `waitTime`(5초): 락을 얻기 위해 대기하는 최대 시간. 무한 대기를 방지하여 스레드 고갈을 막습니다.
    - `leaseTime`(10초): 락을 획득한 후 유지하는 시간. 서버 장애 등으로 락을 해제하지 못하더라도 자동으로 해제되도록 하여 데드락(Deadlock)을 방지했습니다.

## 3. V3: Kafka 대기열(Queue) 시스템 적용

### 왜 Kafka를 사용했는가?

- **공정한 순서 보장 (FIFO)**:
    - V2의 분산락은 락 획득 순서를 완벽하게 보장하지 못할 수 있습니다(비공정 락).
    - Kafka는 **Partition 내에서 메시지 순서를 엄격하게 보장**합니다. `storeId`를 파티션 키로 사용하면 동일 상점에 대한 요청은 무조건 순서대로 처리됩니다.

- **비동기 처리 및 부하 제어 (Backpressure)**:
    - 인기 맛집의 경우 순간적으로 수천 건의 요청이 몰릴 수 있습니다. 동기 방식(V2)은 WAS 스레드를 점유하여 전체 시스템 장애로 이어질 수 있습니다.
    - Kafka를 버퍼(Buffer)로 사용하여 요청을 일단 받아두고(Produce), 서버가 처리할 수 있는 속도로 천천히 가져와서 처리(Consume)함으로써 **DB와 애플리케이션 서버를 보호**할 수 있습니다.

- **기존 인프라 활용**:
    - 이미 구축된 Kafka 인프라가 있어 즉시 적용 가능했습니다.

### 구현 상세 및 근거

- **아키텍처 흐름**:
    1. **Request**: 클라이언트가 `/v3` 엔드포인트(`UserStoreWaiting`, `AppWaiting`) 호출.
    2. **Produce**: 각 서비스(`...V3Service`)가 Kafka의 `waiting-registration-request` 토픽으로 이벤트 발행.
       - **Key**: `storeId` (순서 보장 핵심).
       - **Payload**: 단순 JSON 포맷. DB 저장(`DddEventRepository`)을 생략하여 처리 속도를 극대화했습니다(Fire-and-Forget).
    3. **Response**: 서버는 `traceId`와 함께 "접수됨(QUEUED)" 상태를 즉시 응답.
    4. **Consume**: `WaitingRegistrationConsumer`가 메시지를 수신하여 `channel` 값에 따라 적절한 서비스(`User` or `App`)로 분기 처리.
    5. **Notify**: 처리가 완료되면 SSE(`StoreWaitingSseEventPublisher`)를 통해 클라이언트에게 알림.
 
- **이벤트 객체 확장**:
    - `StoreWaitingRegisterRequestEvent` 객체에 `channel`, `name`, `phoneNumber` 등의 필드를 추가하여, `User` (온라인) 웨이팅과 `App` (오프라인) 웨이팅 요청을 모두 처리할 수 있는 공통 이벤트 모델을 설계했습니다.

- **DLQ (Dead Letter Queue) 도입**:
    - 메시지 파싱 실패나 비즈니스 로직 에러 발생 시, 해당 메시지를 버리지 않고 `waiting-registration-dlq` 토픽으로 전송합니다.
    - **Header 활용**: `error-type` (PARSING_ERROR, PROCESSING_ERROR) 헤더를 추가하여 실패 원인을 쉽게 파악하고 추후 재처리할 수 있도록 했습니다.

## 4. 결론

웨이팅 신청 기능은 데이터 정합성과 대용량 트래픽 처리가 동시에 요구되는 핵심 기능입니다.
- **V2 (Redisson)**: 분산락을 통해 데이터 정합성 문제를 해결했습니다.
- **V3 (Kafka)**: 대기열 시스템을 도입하여 **순서 보장**과 **시스템 안정성(부하 제어)**을 확보했습니다.

결과적으로 사용자는 공정한 순서로 웨이팅을 신청할 수 있으며, 서비스는 트래픽 폭주 상황에서도 안정적으로 운영될 수 있는 견고한 아키텍처를 갖추게 되었습니다. 또한 폴링 API와 확장된 이벤트 모델을 통해 다양한 클라이언트 환경과 웨이팅 채널을 유연하게 지원할 수 있게 되었습니다.
