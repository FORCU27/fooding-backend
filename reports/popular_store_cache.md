# 인기 매장 조회 캐싱 적용 보고서

## 1. 적용 배경

인기 매장 조회 API는 호출 빈도가 높고, 매번 DB 조회 및 정렬 연산이 수행되어 응답 지연과 부하가 발생  
특히 서비스 규모가 커질 경우, 가장 많은 요청이 들어오는 엔드포인트가 될 것으로 예상되며 이에 대한 성능 최적화가 필요

---

## 2. 문제 원인 분석

### 2-1. 리뷰 기반 인기 산정의 특성
- 인기 매장은 **리뷰 개수**를 기준으로 산정
- 많은 사용자가 리뷰를 남기는 서비스 특성상 매장 리뷰 데이터는 **자주 변화**
- TTL을 무한으로 설정한 캐시 전략을 사용할 경우:
    - 리뷰가 달릴 때마다 캐시 무효화 및 재생성이 발생
    - 인기 매장 리스트 요청 빈도가 높기 때문에 재생성 과정의 오버헤드 증가
    - 결과적으로 캐싱의 장점이 희석될 가능성

### 2-2. 기존 API 설계의 한계
- 기존 요청 방식:  
  `/user/stores?sortType=REVIEW&sortDirection=DESCENDING&pageNum=1&pageSize=10`
- 프론트에서 쿼리 파라미터로 정렬 기준을 전달하는 방식은 다음과 같은 문제 발생 가는:
- “리뷰 개수 기반 인기 매장 조회”라는 **비즈니스 정책이 API 설계에 명확히 드러나지 않음**
- 인기 매장 선정 기준이 변경될 경우 프론트와 백엔드가 모두 수정되어야 함
- 정책은 백엔드의 책임 범위이므로 API 차원에서 분리하는 것이 적절

---

## 3. 해결 전략

### 3-1. TTL 기반 Redis 캐싱 적용
- 인기 매장 조회 결과를 Redis에 캐싱하여 반복 요청 처리 성능을 향상
- TTL 20분 설정
- 리뷰가 추가되더라도 일정 주기로 캐시가 자연스럽게 최신화
- 캐시 재생성 오버헤드 최소화
- 데이터 신선도와 성능 간 균형 확보

### 3-2 전용 API 신설
- 새로운 API를 생성하여 인기 매장 조회를 명확하게 분리  
  `/user/stores/popular`
- 장점
- 비즈니스 정책이 명확해짐
- API 명세만으로도 “인기 매장 조회” 기능을 바로 이해 가능
- 추후 인기 산정 기준이 변경되어도 백엔드 수정만으로 대응 가능

---

## 4. 성능 테스트 결과

### 테스트 환경
- k6 부하 테스트 (10 VUs × 30s)
- `/user/stores/popular` 비교

| 구분 | 평균 응답 시간 | 최대 응답 시간 | P90 |
|------|----------------|----------------|-----|
| 캐시 미적용 | 74.65 ms | 625.26 ms | 81.38 ms |
| 캐시 적용 | 21.84 ms | 38.84 ms | 25.94 ms |

→ 평균 응답 속도 약 **3.4배 개선**, 응답 변동성도 크게 감소

### curl 단건 요청 비교

| 구분 | 최초 DB 조회 포함 | 캐시 HIT |
|------|------------------|----------|
| StartTransfer | 0.038472s | 0.026543s |
| Total | 0.038613s | 0.027022s |

→ 단건 호출에서도 DB 접근 제거로 인한 개선 확인

---

## 5. 결론

| 요구 사항 | 적용 내용 |
|----------|-----------|
| 인기 매장 조회 성능 최적화 | Redis 캐시 도입 |
| 잦은 데이터 변경에 대응 | TTL 기반 자동 동기화 |
| 비즈니스 정책 명확화 | 전용 API 생성 (`/user/stores/popular`) |

## 기대 효과

1. 인기 매장 조회 트래픽이 높아질수록 **캐싱 효과가 극대화**
2. DB 부하 감소로 **전체 서비스 안정성 향상**
3. API 명세와 정책 일관성 유지로 **유지보수 비용 절감**
